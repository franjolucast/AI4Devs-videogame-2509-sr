<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Retro Tennis – Partido</title>
    <link rel="stylesheet" href="css/styles.css">

    <style>
        .hud-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 0.9rem;
        }
        #game-canvas {
            display: block;
            margin: 12px auto;
            border-radius: 6px;
            border: 4px solid #ffffff;
        }
    </style>
</head>

<body class="app-body">
<div class="screen">

    <h1 class="game-title">Partido de tenis</h1>

    <section class="panel">

        <div class="hud-row">
            <span><strong>Jugador:</strong> <span id="hud-player-name"></span></span>
            <span><strong>Rival:</strong> <span id="hud-opponent-name"></span></span>
        </div>

        <div class="hud-row">
            <span><strong>Dificultad:</strong> <span id="hud-difficulty"></span></span>
            <span><strong>Sets:</strong> <span id="hud-sets"></span></span>
        </div>

        <div class="hud-row">
            <span><strong>Games:</strong> <span id="hud-games"></span></span>
            <span><strong>Marcador:</strong> <span id="hud-points"></span></span>
        </div>

        <canvas id="game-canvas" width="420" height="640"></canvas>

        <p style="margin-top:6px; font-size:0.8rem; opacity:0.8;">
            Controles: Flechas/WASD para moverte · Barra espaciadora para golpear.
        </p>

        <button id="back-home" class="btn secondary" style="margin-top:10px;">
            &laquo; Volver a Home
        </button>

    </section>

</div>

<!-- ========================================================= -->
<!-- ===============   GAME LOOP INCRUSTADO   ================ -->
<!-- ========================================================= -->
<script>
// -------------- utilidades -------------------
function loadGameConfig() {
    try {
        const raw = sessionStorage.getItem("retroTennis_config");
        if (!raw) return null;
        return JSON.parse(raw);
    } catch { return null; }
}

// ----------------- SCORING --------------------
class TennisScoring {
    constructor(setFormat = 1) {
        this.setFormat = setFormat;
        this.resetMatch();
    }
    resetMatch() {
        this.playerGames = 0;
        this.opponentGames = 0;
        this.playerSets = 0;
        this.opponentSets = 0;
        this.playerPoints = 0;
        this.opponentPoints = 0;
        this.matchFinished = false;
        this.playerAdv = false;
        this.opponentAdv = false;
    }
    getDisplayPoints(isPlayer) {
        const p = isPlayer ? this.playerPoints : this.opponentPoints;
        if (this.playerPoints >= 3 && this.opponentPoints >= 3) {
            if (this.playerAdv) return isPlayer ? "AD" : "40";
            if (this.opponentAdv) return isPlayer ? "40" : "AD";
            return "40";
        }
        return ["0","15","30","40"][p];
    }
    pointWonBy(who) {
        if (this.matchFinished) return;
        const isPlayer = who === "player";
        if (this.playerPoints >= 3 && this.opponentPoints >= 3) {
            if (isPlayer) {
                if (this.opponentAdv) this.opponentAdv = false;
                else if (this.playerAdv) this.winGame(true);
                else this.playerAdv = true;
            } else {
                if (this.playerAdv) this.playerAdv = false;
                else if (this.opponentAdv) this.winGame(false);
                else this.opponentAdv = true;
            }
            return;
        }
        if (isPlayer) {
            this.playerPoints++;
            if (this.playerPoints >= 4) this.winGame(true);
        } else {
            this.opponentPoints++;
            if (this.opponentPoints >= 4) this.winGame(false);
        }
    }
    winGame(playerWon) {
        if (playerWon) this.playerGames++;
        else this.opponentGames++;
        this.playerPoints = 0;
        this.opponentPoints = 0;
        this.playerAdv = false;
        this.opponentAdv = false;
        if (this.isSetWon()) {
            if (playerWon) this.playerSets++;
            else this.opponentSets++;
            this.playerGames = 0;
            this.opponentGames = 0;
            if (this.isMatchWon()) this.matchFinished = true;
        }
    }
    isSetWon() {
        const p = this.playerGames, o = this.opponentGames;
        return (p >= 6 || o >= 6) && Math.abs(p - o) >= 2;
    }
    isMatchWon() {
        return this.playerSets === Math.ceil(this.setFormat/2)
            || this.opponentSets === Math.ceil(this.setFormat/2);
    }
}

// ====================================================
// ===================== GAME =========================
// ====================================================

const config = loadGameConfig();
if (!config) {
    alert("No se pudo cargar la configuración.");
    window.location.href = "index.html";
}

const canvas = document.getElementById("game-canvas");
const ctx = canvas.getContext("2d");

document.getElementById("hud-player-name").textContent = config.playerName;
document.getElementById("hud-opponent-name").textContent = "Rival";
document.getElementById("hud-difficulty").textContent = config.difficulty.toUpperCase();
document.getElementById("hud-sets").textContent = config.sets;

// Tamaños
const WIDTH = canvas.width;
const HEIGHT = canvas.height;

const baselineOffset = 60;
const courtPaddingX = 30;
const netY = HEIGHT / 2;

// Jugador
const player = {
    x: WIDTH/2,
    y: HEIGHT - baselineOffset,
    width: 14,
    height: 40,
    speed: 260,
    swingTimer: 0
};

// Rival
const opponent = {
    x: WIDTH/2,
    y: baselineOffset,
    width: 14,
    height: 40,
    speed: 260,
    swingCooldown: 0
};

// Pelota
const ball = {
    x: player.x,
    y: player.y - 30,
    radius: 5,
    vx: 0,
    vy: 0,
    inPlay: false,
    lastHitter: "player"
};

// Saque alternado por juego
let server = "player";

// Scoring
const scoring = new TennisScoring(config.sets);

// Entrada teclado
const keys = {};
window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

// ---------------- Loop ----------------
let lastTime = performance.now();
requestAnimationFrame(gameLoop);

function gameLoop(t) {
    const dt = Math.min(0.033, (t - lastTime) / 1000);
    lastTime = t;

    update(dt);
    render();

    requestAnimationFrame(gameLoop);
}

// ---------------- Update ----------------
function update(dt) {
    handlePlayer(dt);
    handleOpponent(dt);
    handleBall(dt);
}

// Jugador
function handlePlayer(dt) {
    let dx = 0, dy = 0;
    if (keys["arrowleft"] || keys["a"]) dx = -1;
    if (keys["arrowright"]|| keys["d"]) dx = 1;
    if (keys["arrowup"]   || keys["w"]) dy = -1;
    if (keys["arrowdown"] || keys["s"]) dy = 1;

    const len = Math.hypot(dx, dy) || 1;
    dx/=len; dy/=len;

    player.x += dx * player.speed * dt;
    player.y += dy * player.speed * dt;

    // Límites
    if (player.x < courtPaddingX) player.x = courtPaddingX;
    if (player.x > WIDTH - courtPaddingX) player.x = WIDTH - courtPaddingX;
    if (player.y < netY + 20) player.y = netY + 20;
    if (player.y > HEIGHT - baselineOffset) player.y = HEIGHT - baselineOffset;

    if (keys[" "]) player.swingTimer = 0.18;
    else if (player.swingTimer > 0) player.swingTimer -= dt;

    // Preparar saque
    if (!ball.inPlay && server === "player") {
        ball.x = player.x + 10;
        ball.y = player.y - 30;
        if (keys[" "]) serveFromPlayer();
    }
}

// Rival
function handleOpponent(dt) {
    if (!ball.inPlay && server === "opponent") {
        ball.x = opponent.x - 10;
        ball.y = opponent.y + 30;
        setTimeout(()=>{ if(!ball.inPlay) serveFromOpponent(); },400);
    }

    if (ball.inPlay) {
        const tx = ball.x;
        const ty = Math.min(ball.y, netY - 40);
        moveTowards(opponent, tx, ty, opponent.speed, dt);
    } else {
        moveTowards(opponent, WIDTH/2, baselineOffset, opponent.speed, dt);
    }

    if (opponent.x < courtPaddingX) opponent.x = courtPaddingX;
    if (opponent.x > WIDTH - courtPaddingX) opponent.x = WIDTH - courtPaddingX;
    if (opponent.y < baselineOffset) opponent.y = baselineOffset;
    if (opponent.y > netY - 40) opponent.y = netY - 40;

    if (opponent.swingCooldown > 0) opponent.swingCooldown -= dt;
}

// Movimiento IA
function moveTowards(e, tx, ty, speed, dt) {
    const dx = tx - e.x;
    const dy = ty - e.y;
    const d = Math.hypot(dx,dy);
    if (d < 1) return;
    e.x += (dx/d)*speed*dt;
    e.y += (dy/d)*speed*dt;
}

// Pelota
function handleBall(dt) {
    if (!ball.inPlay) return;

    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;

    // LATERAL → punto
    if (ball.x < courtPaddingX - ball.radius) return pointWon("opponent");
    if (ball.x > WIDTH-courtPaddingX + ball.radius) return pointWon("player");

    // Fondo → punto
    if (ball.y < -10) return pointWon("player");
    if (ball.y > HEIGHT+10) return pointWon("opponent");

    checkPlayerHit();
    checkOpponentHit();
}

// Golpes
function checkPlayerHit() {
    if (!ball.inPlay || ball.vy <= 0) return;

    const dx = ball.x - (player.x + 10);
    const dy = ball.y - (player.y - 20);
    if (Math.hypot(dx,dy) < 28 && player.swingTimer > 0) {
        hitBall("player");
    }
}

function checkOpponentHit() {
    if (!ball.inPlay || ball.vy >= 0) return;

    const dx = ball.x - (opponent.x - 10);
    const dy = ball.y - (opponent.y + 20);
    if (Math.hypot(dx,dy) < 28 && opponent.swingCooldown <= 0) {
        hitBall("opponent");
        opponent.swingCooldown = 0.25;
    }
}

function hitBall(who) {
    ball.lastHitter = who;
    const base = 300;
    const angle = (Math.random()*60)+60;
    const rad = angle*Math.PI/180;

    ball.vx = Math.cos(rad)*base;
    ball.vy = (who==="player"? -1 : 1)*Math.abs(Math.sin(rad)*base);
}

function serveFromPlayer() {
    ball.inPlay = true;
    ball.lastHitter="player";
    const ang=80*Math.PI/180;
    const sp=300;
    ball.vx=Math.cos(ang)*sp;
    ball.vy=-Math.abs(Math.sin(ang)*sp);
}
function serveFromOpponent() {
    ball.inPlay = true;
    ball.lastHitter="opponent";
    const ang=80*Math.PI/180;
    const sp=300;
    ball.vx=Math.cos(ang)*sp;
    ball.vy=Math.abs(Math.sin(ang)*sp);
}

// Puntos
function pointWon(who) {
    scoring.pointWonBy(who);

    // Mostrar HUD
    hudUpdate();

    // Juego terminado → alternar saque
    if (scoring.playerPoints === 0 && scoring.opponentPoints === 0) {
        server = (server==="player" ? "opponent" : "player");
    }

    if (scoring.matchFinished) {
        alert("Partido terminado\n" +
              config.playerName + ": " + scoring.playerSets +
              " - Rival: " + scoring.opponentSets);
        window.location.href = "index.html";
        return;
    }

    resetPoint();
}

function resetPoint() {
    ball.inPlay=false;
    ball.vx=0;
    ball.vy=0;

    if (server==="player") {
        ball.x=player.x;
        ball.y=player.y-30;
    } else {
        ball.x=opponent.x;
        ball.y=opponent.y+30;
    }
}

// HUD
function hudUpdate() {
    document.getElementById("hud-games").textContent =
        scoring.playerGames + " - " + scoring.opponentGames;

    document.getElementById("hud-points").textContent =
        scoring.getDisplayPoints(true) + " - " + scoring.getDisplayPoints(false);
}

// ---------------- Render ----------------
function render() {
    // Pista
    ctx.fillStyle = getSurfaceColor(config.surface);
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    ctx.strokeStyle="#fff";
    ctx.lineWidth=3;

    const top=baselineOffset;
    const bottom=HEIGHT-baselineOffset;
    const left=courtPaddingX;
    const right=WIDTH-courtPaddingX;

    ctx.strokeRect(left,top,right-left,bottom-top);

    // Red
    ctx.fillStyle="#fff";
    ctx.fillRect(left,netY-1,right-left,2);

    // Líneas de saque
    const st=netY-(HEIGHT*0.16);
    const sb=netY+(HEIGHT*0.16);
    ctx.fillRect(left,st-1,right-left,2);
    ctx.fillRect(left,sb-1,right-left,2);
    // Centro
    ctx.fillRect(WIDTH/2-1,st,2,sb-st);

    drawPlayer(player,false);
    drawPlayer(opponent,true);

    // Pelota
    ctx.beginPath();
    ctx.arc(ball.x,ball.y,ball.radius,0,Math.PI*2);
    ctx.fillStyle="#ffff66";
    ctx.fill();
}

function drawPlayer(p,isOpponent){
    ctx.fillStyle = isOpponent ? "#ffe08a" : "#f6e9ff";

    ctx.fillRect(p.x-p.width/2,p.y-p.height,p.width,p.height);

    ctx.beginPath();
    ctx.arc(p.x,p.y-p.height-8,8,0,Math.PI*2);
    ctx.fill();

    ctx.strokeStyle=ctx.fillStyle;
    ctx.lineWidth=2;

    const rx = isOpponent ? p.x-12 : p.x+12;
    const ry = p.y-p.height+10;

    ctx.beginPath();
    ctx.arc(rx,ry,8,0,Math.PI*2);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(p.x + (isOpponent?-2:+2), p.y-p.height+15);
    ctx.lineTo(rx + (isOpponent?+4:-4), ry+6);
    ctx.stroke();
}

function getSurfaceColor(s){
    switch(s){
        case "clay": return "#c95b1a";
        case "grass":return "#2a8f33";
        case "hard": return "#1f3b8a";
    }
}

document.getElementById("back-home")
    .addEventListener("click",()=>window.location.href="index.html");

hudUpdate();
</script>
</body>
</html>
